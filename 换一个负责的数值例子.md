## 输入 nums = [2,8,15,20,50] target = 58 输出 [1,4]。一步一步解析这个计算步骤。

**按代码一行一行、一步一步跑**，看到字典 `seen` 怎么变化，为什么最后输出 `[1,4]`。

```python
seen = {}
for i, x in enumerate(nums):
    need = target - x
    if need in seen:
        return [seen[need], i]
    seen[x] = i
```

输入：

* `nums = [2, 8, 15, 20, 50]`
* `target = 58`

---

## 初始状态

* `seen = {}`（空字典）
* 还没开始循环

---

# 第1轮循环

`enumerate(nums)` 第一次给出 `(i, x) = (0, 2)`

* `i = 0`
* `x = 2`

计算：

* `need = target - x = 58 - 2 = 56`

检查：

* `if need in seen:` 也就是 `56 in {}`？
* 结果：**不在**（False），因为 `seen` 还是空的

于是执行记录：

* `seen[x] = i` 也就是 `seen[2] = 0`

此时：

* `seen = {2: 0}`

---

# 第2轮循环

第二次 `(i, x) = (1, 8)`

* `i = 1`
* `x = 8`

计算：

* `need = 58 - 8 = 50`

检查：

* `50 in seen`？
* 现在 `seen = {2:0}`，只有键 `2`
* 所以 **50 不在**（False）

记录：

* `seen[8] = 1`

此时：

* `seen = {2: 0, 8: 1}`

---

# 第3轮循环

第三次 `(i, x) = (2, 15)`

* `i = 2`
* `x = 15`

计算：

* `need = 58 - 15 = 43`

检查：

* `43 in seen`？
* `seen` 里只有 `2` 和 `8`
* 所以 **不在**（False）

记录：

* `seen[15] = 2`

此时：

* `seen = {2: 0, 8: 1, 15: 2}`

---

# 第4轮循环

第四次 `(i, x) = (3, 20)`

* `i = 3`
* `x = 20`

计算：

* `need = 58 - 20 = 38`

检查：

* `38 in seen`？
* `seen` 里有 `2, 8, 15`
* 所以 **不在**（False）

记录：

* `seen[20] = 3`

此时：

* `seen = {2: 0, 8: 1, 15: 2, 20: 3}`

---

# 第5轮循环（找到答案了）

第五次 `(i, x) = (4, 50)`

* `i = 4`
* `x = 50`

计算：

* `need = 58 - 50 = 8`

检查：

* `8 in seen`？
* 现在 `seen` 里确实有键 `8`，而且 `seen[8] = 1`
* 所以 **在**（True）

执行返回：

```python
return [seen[need], i]
```

这里：

* `need = 8`
* `seen[need] = seen[8] = 1`
* `i = 4`

所以返回：

* `[1, 4]`

---

## ✅ 为什么是 `[1,4]`？

因为：

* `nums[1] = 8`
* `nums[4] = 50`
* `8 + 50 = 58`（正好等于 target）

而题目要返回的是 **下标**，不是数值，所以输出 `[1,4]`。

---

如果你愿意，我也可以把这次运行过程用表格画出来（每一轮的 i、x、need、seen 变化），会更直观。
